// Generated by CoffeeScript 1.6.3
(function() {
  var expect, state;

  expect = require('chai').expect;

  state = require('state');

  describe("Linearization:", function() {
    var expressions, orderOf, reducer;
    reducer = function(out, s) {
      if (out) {
        out += ' ';
      }
      return out += s.name || '<ROOT>';
    };
    orderOf = function(s) {
      return s.linearize().reduce(reducer, '');
    };
    expressions = {
      'long diamond': state({
        A: state,
        B: state,
        C: state.extend('A'),
        D: state.extend('B'),
        E: state.extend('C, D')
      }),
      'folded triple diamond': state({
        A: state,
        B: state,
        C: state,
        D: state.extend('A, B'),
        E: state.extend('A, C'),
        F: state.extend('D, E')
      }),
      'tesselated triple diamond': state({
        A: state,
        B: state,
        C: state,
        D: state.extend('A, B'),
        E: state.extend('B, C'),
        F: state.extend('D, E')
      }),
      'hierarchical TTD': state({
        A: state,
        B: state({
          D: state.extend('A')
        }),
        C: state({
          E: state.extend('B', {
            F: state.extend('D')
          })
        })
      })
    };
    it("computes the monotonic order of parastates and superstates", function() {
      var o;
      state(o = {}, expressions['long diamond']);
      expect(orderOf(o.state(''))).to.equal('<ROOT>');
      expect(orderOf(o.state('A'))).to.equal('A <ROOT>');
      expect(orderOf(o.state('B'))).to.equal('B <ROOT>');
      expect(orderOf(o.state('C'))).to.equal('C A <ROOT>');
      expect(orderOf(o.state('D'))).to.equal('D B <ROOT>');
      return expect(orderOf(o.state('E'))).to.equal('E C A D B <ROOT>');
    });
    it("computes monotonic order equivalently via protostates", function() {
      var Class, o;
      Class = (function() {
        function Class() {}

        state(Class.prototype, expressions['long diamond']);

        return Class;

      })();
      o = new Class;
      expect(orderOf(o.state(''))).to.equal('<ROOT>');
      expect(orderOf(o.state('A'))).to.equal('A <ROOT>');
      expect(orderOf(o.state('B'))).to.equal('B <ROOT>');
      expect(orderOf(o.state('C'))).to.equal('C A <ROOT>');
      expect(orderOf(o.state('D'))).to.equal('D B <ROOT>');
      return expect(orderOf(o.state('E'))).to.equal('E C A D B <ROOT>');
    });
    it("computes order via protostates, parastates, and superstates", function() {
      var Class, o;
      Class = (function() {
        function Class() {}

        state(Class.prototype, expressions['hierarchical TTD']);

        return Class;

      })();
      o = new Class;
      state(o, {
        C: {
          E: {
            G: state.extend('D')
          }
        }
      });
      expect(orderOf(o.state('G'))).to.equal('G D A E B C <ROOT>');
      o = new Class;
      state(o, {
        C: {
          E: {
            G: {
              H: state.extend('D')
            }
          }
        }
      });
      return expect(orderOf(o.state('H'))).to.equal('H D A G E B C <ROOT>');
    });
    it("resolves the folded-triple-diamond formation", function() {
      var o;
      state(o = {}, expressions['folded triple diamond']);
      return expect(orderOf(o.state('F'))).to.equal('F D E A B C <ROOT>');
    });
    it("resolves the tesselated-triple-diamond formation", function() {
      var o;
      state(o = {}, expressions['tesselated triple diamond']);
      return expect(orderOf(o.state('F'))).to.equal('F D A E B C <ROOT>');
    });
    return it("preserves monotonicity with parastates-precede-superstate rule", function() {
      var o;
      state(o = {}, expressions['hierarchical TTD']);
      return expect(orderOf(o.state('F'))).to.equal('F D A E B C <ROOT>');
    });
  });

}).call(this);
