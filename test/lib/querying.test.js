// Generated by CoffeeScript 1.6.3
(function() {
  var RootState, State, expect, state;

  expect = require('chai').expect;

  state = require('state');

  State = state.State, RootState = state.RootState;

  describe("Querying `State`s", function() {
    describe("within an objectâ€™s state tree", function() {
      var a, b, ba, bb, bba, object, root;
      object = {};
      state(object, {
        A: state,
        B: state({
          BA: state,
          BB: state({
            BBA: state,
            BBB: state
          })
        }),
        BBB: state
      });
      root = object.state('');
      a = b = ba = bb = bba = null;
      it("resolves top-level substates by name", function() {
        expect(a = object.state('A')).to.be["instanceof"](State);
        expect(a.superstate).to.equal(root);
        expect(b = object.state('B')).to.be["instanceof"](State);
        return expect(b.superstate).to.equal(root);
      });
      it("resolves descendant substates by fully-qualified path", function() {
        expect(ba = object.state('B.BA')).to.be["instanceof"](State);
        expect(ba.superstate).to.equal(b);
        expect(bb = object.state('B.BB')).to.be["instanceof"](State);
        expect(bb.superstate).to.equal(b);
        expect(bba = object.state('B.BB.BBA')).to.be["instanceof"](State);
        return expect(bba.superstate).to.equal(bb);
      });
      it("resolves non-ambiguously named descendants by name", function() {
        bba = object.state('B.BB.BBA');
        return expect(object.state('BBA')).to.equal(bba);
      });
      it("resolves absolute paths to ambiguously named descendants", function() {
        var bbb;
        bbb = object.state('BBB');
        bb = object.state('BB');
        expect(bbb.superstate).to.equal(root);
        return expect(bbb.superstate).to.not.equal(bb);
      });
      it("employs recursive descent to disambiguate relative paths", function() {
        var path, s1, s2;
        b = object.state('B');
        path = '.BBB';
        expect(s1 = b.query(path)).to.not.equal(s2 = root.query(path));
        return expect(s1.superstate.superstate.superstate).to.equal(s2.superstate);
      });
      return it("employs recursive ascent", function() {
        a = object.state('A');
        bb = object.state('BB');
        return expect(bb.query('.A')).to.equal(a);
      });
    });
    return describe("across prototypes:", function() {
      var Child, Parent;
      Parent = (function() {
        function Parent() {}

        state(Parent.prototype, {
          A: state,
          B: state
        });

        return Parent;

      })();
      Child = (function() {
        function Child() {}

        state(Child.prototype, {
          B: {
            BA: state,
            BB: {
              BBA: state
            }
          }
        });

        return Child;

      })();
      return describe("An inheritor", function() {
        var object;
        object = new Child;
        return it("initializes to a realized root state", function() {
          var current;
          current = object.state();
          expect(current).to.be["instanceof"](RootState);
          return expect(current.isVirtual()).to.equal(false);
        });
      });
    });
  });

  /*
  
    do ->
      class Class
        state @::,
          A: state
          B: state
            BA: state
            BB: state
              BBA: state
  
      describe "", ->
  */


}).call(this);
