// Generated by CoffeeScript 1.6.3
(function() {
  var GuardMap, VIA_PROTO, expect, falsePredicate, state, truePredicate;

  expect = require('chai').expect;

  state = require('state');

  GuardMap = state.GuardMap;

  VIA_PROTO = state.TRAVERSAL_FLAGS.VIA_PROTO;

  truePredicate = function() {
    return true;
  };

  falsePredicate = function() {
    return false;
  };

  describe("GuardMap constructor", function() {
    describe("with an object-typed `expression` argument:", function() {
      var expression, gm;
      gm = new GuardMap('aGuardType', expression = {
        aSelector: [truePredicate, truePredicate, truePredicate],
        anotherSelector: truePredicate
      });
      it("writes to `guardType`", function() {
        return expect(gm.guardType).to.equal('aGuardType');
      });
      it("writes the interpreted `expression` to `this.map`", function() {
        return expect(Object.keys(gm.map).join(' ')).to.equal('aSelector anotherSelector');
      });
      return it("boxes a function value inside an array", function() {
        expect(gm.map.aSelector).to.have.length(3);
        return expect(gm.map.anotherSelector).to.have.length(1);
      });
    });
    describe("with a string `expression`:", function() {
      var expression, gm;
      gm = new GuardMap('aGuardType', expression = 'justAString');
      return it("interprets the string as a selector and true predicate", function() {
        expect(gm.guardType).to.equal('aGuardType');
        expect(gm.map.justAString).to.have.length(1);
        return expect(gm.map.justAString[0]()).to.equal(true);
      });
    });
    describe("with a function `expression`:", function() {
      var expression, gm;
      gm = new GuardMap('aGuardType', expression = function() {
        return 42;
      });
      it("associates with the any-state selector", function() {
        return expect(gm.map['***']).to.exist;
      });
      return it("instates the provided function as the lone predicate", function() {
        expect(gm.map['***']).to.have.length(1);
        return expect(gm.map['***'][0]()).to.equal(42);
      });
    });
    describe("with an array `expression`:", function() {
      var expression, gm, that;
      gm = new GuardMap('aGuardType', expression = ['everything here must be coerced', /^into predicates$/, that = true]);
      it("associates with the any-state selector", function() {
        expect(gm.guardType).to.equal('aGuardType');
        return expect(gm.map['***']).to.have.length(3);
      });
      return it("coerces elements to true predicates", function() {
        var p, _i, _len, _ref, _results;
        expect(typeof gm.map['***'][0]).to.equal('function');
        truePredicate = gm.map['***'][0];
        _ref = gm.map['***'];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          _results.push(expect(p).to.equal(truePredicate));
        }
        return _results;
      });
    });
    return describe("with any other type of `expression`:", function() {
      var expression, gm;
      gm = new GuardMap('aGuardType', expression = 0);
      it("associates with the any-state selector", function() {
        expect(gm.guardType).to.equal('aGuardType');
        return expect(gm.map['***']).to.have.length(1);
      });
      return it("converts the value to a predicate thunk", function() {
        return expect(gm.map['***'][0]()).to.equal(false);
      });
    });
  });

  describe("GuardMap::add", function() {
    it("writes arguments to `map` property", function() {
      var guardMap;
      guardMap = new GuardMap('aGuardType');
      guardMap.add('A', [truePredicate, falsePredicate]);
      expect(guardMap.guardType).to.equal('aGuardType');
      expect(guardMap.map.A).to.be.an.array;
      expect(guardMap.map.A).to.have.length(2);
      expect(guardMap.map.A[0]).to.equal(truePredicate);
      return expect(guardMap.map.A[1]).to.equal(falsePredicate);
    });
    return it("writes function-typed `predicates` argument as array", function() {
      var guardMap;
      guardMap = new GuardMap('aGuardType');
      guardMap.add('A', truePredicate);
      expect(guardMap.map.A).to.be.an.array;
      expect(guardMap.map.A).to.have.length(1);
      return expect(guardMap.map.A[0]).to.equal(truePredicate);
    });
  });

  describe("GuardMap::remove", function() {});

  describe("GuardMap::evaluate", function() {
    var Class, object, stateA, stateB, stateC;
    Class = (function() {
      function Class() {}

      state(Class.prototype, 'abstract', {
        A: state,
        B: state,
        C: state
      });

      return Class;

    })();
    object = new Class;
    stateA = object.state('A');
    stateB = object.state('B');
    stateC = object.state('C');
    it("arguments are passed to the parameters of predicates", function() {
      var guardMap;
      guardMap = new GuardMap('aGuardType', {
        'A': function(against, as, guardType) {
          return against.name === 'A' && as.name === 'B' && guardType === 'aGuardType';
        }
      });
      return expect(guardMap.evaluate(stateA, stateB)).to.equal(true);
    });
    it("requires all matching guards to pass", function() {
      var guardMap;
      guardMap = new GuardMap('aGuardType', {
        '***': true,
        'A': [
          function(against, as) {
            return true;
          }, function(against, as, guardType) {
            if (guardType === 'aGuardType') {
              return true;
            }
          }, function(against, as) {
            return as.name !== 'C';
          }
        ],
        'B': false
      });
      expect(guardMap.evaluate(stateC, stateB)).to.equal(true);
      expect(guardMap.evaluate(stateB, stateA)).to.equal(false);
      expect(guardMap.evaluate(stateA, stateB)).to.equal(true);
      return expect(guardMap.evaluate(stateA, stateC)).to.equal(false);
    });
    return it("requires at least one guard to pass if any are defined", function() {
      var emptyMap, populatedMap;
      emptyMap = new GuardMap('aGuardType', {});
      expect(emptyMap.evaluate(stateB, stateC)).to.equal(true);
      populatedMap = new GuardMap('aGuardType', {
        'A': true
      });
      return expect(populatedMap.evaluate(stateB, stateC)).to.equal(false);
    });
  });

}).call(this);
