// Generated by CoffeeScript 1.6.3
(function() {
  var RootState, State, bind, diff, env, expect, fix, isEmpty, state, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  expect = require('chai').expect;

  state = require('state');

  env = state.env, bind = state.bind, fix = state.fix, State = state.State, RootState = state.RootState;

  _ref = state.O, isEmpty = _ref.isEmpty, diff = _ref.diff;

  describe("Data:", function() {
    var Class, Superclass, expectation, instanceStateExpression, _ref1;
    Superclass = (function() {
      function Superclass() {}

      state(Superclass.prototype, 'mutable', {
        data: {
          a: 1,
          b: 'shadow me',
          d: 'shadow me'
        },
        A: state({
          data: {
            b: 2,
            c: 'shadow me',
            e: 'shadow me'
          },
          AA: state({
            data: {
              c: 3,
              f: 'shadow me'
            }
          })
        }),
        X: state('abstract', {
          data: {
            x: 24,
            c: 'shadow me'
          }
        })
      });

      return Superclass;

    })();
    Class = (function(_super) {
      __extends(Class, _super);

      function Class() {
        _ref1 = Class.__super__.constructor.apply(this, arguments);
        return _ref1;
      }

      state(Class.prototype, {
        data: {
          d: 4,
          e: 'shadow me',
          g: 'shadow me'
        },
        A: state({
          data: {
            e: 5,
            f: 'shadow me',
            h: 'shadow me'
          },
          AA: state({
            data: {
              f: 6,
              i: 'shadow me'
            }
          })
        }),
        Y: state('abstract', {
          data: {
            f: 'shadow me',
            x: 'shadow me',
            y: 25
          }
        })
      });

      return Class;

    })(Superclass);
    instanceStateExpression = {
      data: {
        g: 7
      },
      A: state({
        data: {
          h: 8
        },
        AA: state.extend('X, Y, Z', 'initial', {
          data: {
            i: 9
          }
        })
      }),
      Z: state('abstract', {
        data: {
          z: 26
        }
      })
    };
    expectation = {
      a: 1,
      b: 2,
      c: 3,
      d: 4,
      e: 5,
      f: 6,
      g: 7,
      h: 8,
      i: 9,
      x: 24,
      y: 25,
      z: 26
    };
    describe("object model", function() {
      return it("is structured properly", function() {
        var instance;
        state(instance = new Class, instanceStateExpression);
        expect(instance.state('X').owner).to.equal(instance);
        expect(instance.state('X').protostate.owner).to.equal(Superclass.prototype);
        expect(instance.state('Y').owner).to.equal(instance);
        expect(instance.state('Y').protostate.owner).to.equal(Class.prototype);
        expect(instance.state('Z').owner).to.equal(instance);
        return expect(instance.state('Z').protostate).to.equal(null);
      });
    });
    describe("data (read):", function() {
      return it("performs proper inheritance and shadowing", function() {
        var instance, residue;
        state(instance = new Class, instanceStateExpression);
        residue = diff(instance.state().data(), expectation);
        return expect(isEmpty(residue)).to.equal(true);
      });
    });
    describe("has:", function() {
      return it("has each expected key", function() {
        var instance, key, value, _results;
        state(instance = new Class, instanceStateExpression);
        _results = [];
        for (key in expectation) {
          value = expectation[key];
          _results.push(expect(instance.state().has(key)).to.equal(true));
        }
        return _results;
      });
    });
    describe("get:", function() {
      return it("gets each expected value", function() {
        var instance, key, value, _results;
        state(instance = new Class, instanceStateExpression);
        _results = [];
        for (key in expectation) {
          value = expectation[key];
          _results.push(expect(instance.state().get(key)).to.equal(value));
        }
        return _results;
      });
    });
    describe("let:", function() {
      return it("writes to the receiving state, does not mutate ancestors", function() {
        var instance;
        state(instance = new Class, instanceStateExpression);
        instance.state()["let"]('a', 'mutated a');
        expect(instance.state().get('a')).to.equal('mutated a');
        expect(instance.state('').get('a')).to.equal(1);
        instance.state()["let"]('x', 'mutated x');
        expect(instance.state().get('x')).to.equal('mutated x');
        return expect(instance.state('X').get('x')).to.equal(24);
      });
    });
    return describe("set:", function() {
      return it("mutates a property on site in state tree, not on protostate", function() {
        var instance;
        state(instance = new Class, instanceStateExpression);
        instance.state().set('a', 'mutated a');
        expect(instance.state().get('a')).to.equal('mutated a');
        expect(instance.state('').get('a')).to.equal(1);
        expect(Superclass.prototype.state('').get('a')).to.equal(1);
        instance.state().set('g', 'mutated g');
        expect(instance.state('').get('g')).to.equal('mutated g');
        instance.state().set('x', 'mutated x');
        expect(instance.state().get('x')).to.equal('mutated x');
        expect(instance.state('X').get('x')).to.equal(24);
        expect(Superclass.prototype.state('X').get('x')).to.equal(24);
        instance.state().set('z', 'mutated z');
        expect(instance.state().get('z')).to.equal('mutated z');
        return expect(instance.state('Z').get('z')).to.equal('mutated z');
      });
    });
  });

}).call(this);
