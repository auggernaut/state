// Generated by CoffeeScript 1.6.3
(function() {
  var RootState, State, bind, env, expect, fix, state;

  expect = require('chai').expect;

  state = require('state');

  env = state.env, bind = state.bind, fix = state.fix, State = state.State, RootState = state.RootState;

  describe("Methods:", function() {
    var Child, Parent, c_Am, c_Az, cm, p_AAm, p_Am, p_m, pm, setup;
    pm = p_m = p_Am = p_AAm = cm = c_Am = c_Az = null;
    Parent = (function() {
      function Parent() {}

      Parent.prototype.m = pm = function() {
        return 'Pm0';
      };

      state(Parent.prototype, {
        m: p_m = function() {
          return 'Pm1';
        },
        A: {
          m: p_Am = function() {
            return 'Pm2';
          },
          AA: {
            m: p_AAm = function() {
              return 'Pm3';
            }
          }
        }
      });

      return Parent;

    })();
    Child = (function() {
      function Child() {}

      Child.prototype.m = cm = function() {
        return 'Cm0';
      };

      state(Child.prototype, {
        A: {
          m: c_Am = function() {
            return 'Cm2';
          },
          z: c_Az = function() {
            return 'Cz2';
          }
        }
      });

      return Child;

    })();
    setup = function() {
      var f, m, o;
      o = new Child;
      o.f = f = function() {
        return 'of0';
      };
      o.m = m = function() {
        return 'om0';
      };
      return {
        o: o,
        f: f,
        m: m
      };
    };
    describe("Own accessor", function() {
      return it("is created upon first invocation of inherited accessor", function() {
        var f, m, o, _ref;
        _ref = setup(), o = _ref.o, f = _ref.f, m = _ref.m;
        expect(o).to.not.have.ownProperty('state');
        o.state();
        return expect(o).to.have.ownProperty('state');
      });
    });
    describe("Dispatchers:", function() {
      it("creates dispatcher", function() {
        expect(Child.prototype.m).to.have.property('isDispatcher');
        return expect(Child.prototype.m.isDispatcher).to.be.ok;
      });
      it("saves original owner method using expando `original` on dispatcher", function() {
        expect(Child.prototype.m).to.have.property('original');
        return expect(Child.prototype.m.original).to.equal(cm);
      });
      it("out-of-state methods are callable, void-typed, heritable via protostate, and have the side-effect of creating an own accessor", function() {
        var f, m, o, _ref;
        _ref = setup(), o = _ref.o, f = _ref.f, m = _ref.m;
        expect(o).to.not.have.ownProperty('state');
        expect(o.z()).to.be.undefined;
        return expect(o).to.have.ownProperty('state');
      });
      it("swizzles owner methods to the root state if there exists a stateful implementation of the method", function() {
        var f, m, o, _ref;
        _ref = setup(), o = _ref.o, f = _ref.f, m = _ref.m;
        o.state();
        expect(m).to.equal(o.state('').method('m'));
        return expect(o.m()).to.equal('om0');
      });
      return it("ignores owner methods for which no stateful implementation exists", function() {
        var f, m, o, _ref;
        _ref = setup(), o = _ref.o, f = _ref.f, m = _ref.m;
        o.state();
        return expect(f).to.equal(o.f);
      });
    });
    describe("Context: state-binding and state-fixing", function() {
      var methods, test;
      methods = {
        normal: function() {
          return this;
        },
        bound: bind(function() {
          return this;
        }),
        fixed: fix(function() {
          return function() {
            return this;
          };
        }),
        both: fix(function() {
          return bind(function() {
            return this;
          });
        })
      };
      test = function(o) {
        it("works for normal functions", function() {
          return expect(o.normal()).to.equal(o);
        });
        it("works for bound functions", function() {
          return expect(o.bound()).to.equal(o.state('A'));
        });
        it("works for fixed functions", function() {
          return expect(o.fixed()).to.equal(o);
        });
        return it("works for functions that are both bound and fixed", function() {
          return expect(o.both()).to.equal(o.state('A'));
        });
      };
      describe("from the autostate", function() {
        var o;
        state(o = {}, {
          A: state('initial', methods)
        });
        return test(o);
      });
      describe("from a substate", function() {
        var o;
        state(o = {}, {
          A: state({
            methods: methods,
            AA: state('initial')
          })
        });
        return test(o, true);
      });
      describe("from an epistate", function() {
        return test(new ((function() {
          function _Class() {}

          state(_Class.prototype, {
            A: state('initial', methods)
          });

          return _Class;

        })()));
      });
      return describe("from an episubstate", function() {
        return test(new ((function() {
          function _Class() {}

          state(_Class.prototype, {
            A: state({
              methods: methods,
              AA: state('initial')
            })
          });

          return _Class;

        })()));
      });
    });
    describe("Destroying an object’s entire state tree", function() {
      return it("must revert an object to its “nascent” condition; any methods previously subsumed into the root state must be returned to their original location on the object", function() {
        var f, m, o, _ref;
        _ref = setup(), o = _ref.o, f = _ref.f, m = _ref.m;
        env.debug = true;
        o.state();
        env.debug = false;
        expect(f).to.equal(o.f);
        expect(m).to.not.equal(o.m);
        o.state('').destroy();
        expect(f).to.equal(o.f);
        return expect(m).to.equal(o.m);
      });
    });
    return describe("Parastate resolution:", function() {
      var Class;
      Class = (function() {
        function Class() {}

        state(Class.prototype, {
          A: state({
            m: function() {
              return 'A';
            },
            D: state.extend('B')
          }),
          B: state,
          C: state({
            E: state.extend('A', {
              F: state.extend('D')
            })
          })
        });

        return Class;

      })();
      return it("works", function() {
        var o;
        o = new Class;
        o.state('-> F');
        return expect(o.m()).to.equal('A');
      });
    });
  });

}).call(this);
