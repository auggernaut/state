// Generated by CoffeeScript 1.6.3
(function() {
  var CURRENCY_STATES, O, Region, STATE_ATTRIBUTES, State, StateExpression, TRAVERSAL_FLAGS, Transition, TransitionExpression, defaultTransitionExpression, state,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  O = require('omicron');

  state = require('./state-function');

  State = require('./state');

  StateExpression = null;

  Transition = null;

  TransitionExpression = null;

  STATE_ATTRIBUTES = state.STATE_ATTRIBUTES, TRAVERSAL_FLAGS = state.TRAVERSAL_FLAGS, CURRENCY_STATES = state.CURRENCY_STATES;

  module.exports = Region = (function(_super) {
    var ABSTRACT, ACTIVE, AUTONOMOUS, BACKGROUNDED, BLOCKED, CONCLUSIVE, CONCURRENT, FINAL, FINALIZED, IMMEDIATE, JOINED, ORTHOGONAL, RETAINED, SINGULAR, SUSPENDED, TERMINATED, TRANSITIONING, VIA_NONE, VIA_PROTO, VIA_SUB, VIA_SUPER, VIRTUAL, VOID, VOLATILE, evaluateGuard, fail, invert, isArray, isEmpty, isPrototypeOf, regionStates, slice, trim, type, _ref, _ref1;

    __extends(Region, _super);

    isPrototypeOf = Object.prototype.isPrototypeOf;

    slice = Array.prototype.slice;

    trim = O.trim, type = O.type, isEmpty = O.isEmpty, isArray = O.isArray, invert = O.invert;

    fail = state.fail;

    _ref = (CONCURRENT = STATE_ATTRIBUTES.CONCURRENT, ORTHOGONAL = STATE_ATTRIBUTES.ORTHOGONAL, SINGULAR = STATE_ATTRIBUTES.SINGULAR, AUTONOMOUS = STATE_ATTRIBUTES.AUTONOMOUS, VOLATILE = STATE_ATTRIBUTES.VOLATILE, STATE_ATTRIBUTES), VIRTUAL = _ref.VIRTUAL, ABSTRACT = _ref.ABSTRACT, CONCLUSIVE = _ref.CONCLUSIVE, FINAL = _ref.FINAL, RETAINED = _ref.RETAINED, IMMEDIATE = _ref.IMMEDIATE;

    VIA_NONE = TRAVERSAL_FLAGS.VIA_NONE, VIA_SUB = TRAVERSAL_FLAGS.VIA_SUB, VIA_SUPER = TRAVERSAL_FLAGS.VIA_SUPER, VIA_PROTO = TRAVERSAL_FLAGS.VIA_PROTO;

    _ref1 = (JOINED = CURRENCY_STATES.JOINED, FINALIZED = CURRENCY_STATES.FINALIZED, TERMINATED = CURRENCY_STATES.TERMINATED, CURRENCY_STATES), VOID = _ref1.VOID, ACTIVE = _ref1.ACTIVE, BACKGROUNDED = _ref1.BACKGROUNDED, BLOCKED = _ref1.BLOCKED, TRANSITIONING = _ref1.TRANSITIONING, SUSPENDED = _ref1.SUSPENDED;

    regionStates = (function() {
      var key, object, value, _ref2;
      _ref2 = object = invert(CURRENCY_STATES);
      for (key in _ref2) {
        value = _ref2[key];
        object[key] = value.toLowerCase();
      }
      return object;
    })();

    function Region(base, name, expression) {
      Region.__super__.constructor.apply(this, arguments);
      this._state = VOID;
      this._current = null;
      this._transition = null;
      this._queue = this.attributes & IMMEDIATE ? null : [];
    }

    Region.prototype.decodeState = function() {
      var key, value, _state;
      _state = this._state;
      return ((function() {
        var _results;
        _results = [];
        for (key in regionStates) {
          value = regionStates[key];
          if (_state & key) {
            _results.push(value);
          }
        }
        return _results;
      })()).join(' ');
    };

    Region.prototype.initialize = function() {
      Region.__super__.initialize.apply(this, arguments);
      this.activate();
      return this;
    };

    Region.prototype.activate = function(initialState) {
      var attributes, current, _ref2, _ref3, _state;
      _state = this._state, attributes = this.attributes;
      if (_state & TERMINATED) {
        throw new Error("'" + (this.path()) + "': incoming currency already TERMINATED");
      }
      current = (_ref2 = (initialState != null ? this.query(initialState) : this.initialSubstate())) != null ? _ref2 : this;
      if (current.attributes & ABSTRACT) {
        current = (_ref3 = current.defaultSubstate()) != null ? _ref3 : current;
      }
      if (current.owner !== this.owner) {
        current = current.virtualize(this);
      }
      this._current = current;
      this._state = ACTIVE;
      if (current.attributes & CONCURRENT) {
        this.fork(current);
      }
      if (_state === SUSPENDED) {
        this.emit('resume', current, VIA_PROTO);
      } else if (_state === VOID) {
        this.emit('initialize', current, VIA_PROTO);
      }
      return current;
    };

    Region.prototype.concurrencyDeactivated = function() {
      var attributes, _current, _ref2, _state;
      attributes = this.attributes, _current = this._current, _state = this._state;
      if (_state & TERMINATED) {
        return;
      }
      if (attributes & AUTONOMOUS) {
        this._state = ACTIVE | BACKGROUNDED;
      } else if (attributes & SINGULAR) {
        this.finalize();
      } else if (attributes & VOLATILE) {
        if ((_ref2 = this._transition) != null) {
          _ref2.abort();
        }
        if (_current.attributes & VIRTUAL) {
          _current.destroy();
        }
        this._current = null;
        this._state = VOID;
      } else {
        this.suspend();
      }
    };

    Region.prototype.suspend = function() {
      if (!(this._state & ACTIVE)) {
        throw new Error("'" + (this.path()) + "': incoming currency must be ACTIVE");
      }
      this._state = SUSPENDED;
      this.emit('suspend', this._current, VIA_PROTO);
    };

    Region.prototype.resume = function() {
      if (!(this._state & SUSPENDED)) {
        throw new Error("'" + (this.path()) + "': incoming currency must be SUSPENDED");
      }
      this._state = ACTIVE;
      this.emit('resume', this._current, VIA_PROTO);
    };

    Region.prototype.finalize = function() {
      var attributes, _current, _state;
      _state = this._state, attributes = this.attributes, _current = this._current;
      if (_state & TERMINATED) {
        throw new Error("'" + (this.path()) + "': incoming currency already TERMINATED");
      }
      _state = FINALIZED;
      if (attributes & SINGULAR) {
        _state |= TERMINATED;
      }
      this._state = _state;
      this.emit('finalize', _current, VIA_PROTO);
      if (_state & TERMINATED) {
        this.emit('terminate', _current, VIA_PROTO);
      }
    };

    Region.prototype.fork = function(target, transition) {
      var name, owner, subregion, subregionState, subtrex, targetAttributes, _ref2, _ref3;
      owner = this.owner;
      targetAttributes = target.attributes;
      if (!(targetAttributes & CONCURRENT)) {
        throw new TypeError;
      }
      if (targetAttributes & VIRTUAL) {
        target.realize();
      }
      _ref2 = target.substates(VIA_PROTO);
      for (name in _ref2) {
        subregion = _ref2[name];
        if (subregion.owner !== owner) {
          subregion = state.own(owner, subregion.path());
        }
        subregionState = subregion._state;
        if (subregionState & TERMINATED) {
          continue;
        }
        if (subtrex = transition != null ? (_ref3 = transition.fork) != null ? _ref3[name] : void 0 : void 0) {
          if (subregionState & VOID) {
            subregion.activate(subtrex.target);
          }
          subregion["do"](subtrex);
        } else {
          if (subregionState & SUSPENDED) {
            subregion.resume();
          } else {
            subregion.activate();
          }
        }
      }
    };

    Region.prototype.join = function() {
      var transition;
      if (this === this.root) {
        throw new TypeError;
      }
      if (this._state & TRANSITIONING) {
        transition = this._current;
      }
      if (transition) {

      }
      this.finalize();
      this._state |= JOINED;
    };

    evaluateGuard = function(context, guard, against) {
      var args, key, result, selector, selectors, value, valueIsFn, _i, _len;
      if (typeof guard === 'string') {
        guard = context.guard(guard);
      }
      if (!guard) {
        return true;
      }
      args = slice.call(arguments, 1);
      for (key in guard) {
        if (!__hasProp.call(guard, key)) continue;
        value = guard[key];
        valueIsFn = typeof value === 'function';
        selectors = trim(key).split(/\s*,+\s*/);
        for (_i = 0, _len = selectors.length; _i < _len; _i++) {
          selector = selectors[_i];
          if (!(context.query(selector, against))) {
            continue;
          }
          result = valueIsFn ? value.apply(context, args) : value;
          break;
        }
        if (!result) {
          break;
        }
      }
      return !!result;
    };

    Region.prototype.isVoid = function() {
      return !!(this._state & VOID);
    };

    Region.prototype.isActive = function() {
      return !!(this._state & ACTIVE);
    };

    Region.prototype.isBackgrounded = function() {
      return !!(this._state & BACKGROUNDED);
    };

    Region.prototype.isBlocked = function() {
      return !!(this._state & BLOCKED);
    };

    Region.prototype.isTransitioning = function() {
      return !!(this._state & TRANSITIONING);
    };

    Region.prototype.isSuspended = function() {
      return !!(this._state & SUSPENDED);
    };

    Region.prototype.isJoined = function() {
      return !!(this._state & JOINED);
    };

    Region.prototype.isFinalized = function() {
      return !!(this._state & FINALIZED);
    };

    Region.prototype.isTerminated = function() {
      return !!(this._state & TERMINATED);
    };

    Region.prototype.getTransitionExpression = (function() {
      var search;
      search = function(target, origin, subject, ceiling) {
        var admit, expr, guards, key, release, _ref2, _ref3;
        while (subject && subject !== ceiling) {
          _ref3 = (_ref2 = subject._) != null ? _ref2.transitions : void 0;
          for (key in _ref3) {
            if (!__hasProp.call(_ref3, key)) continue;
            expr = _ref3[key];
            if ((!(guards = expr.guards) || (!(admit = guards.admit) || isEmpty(admit) || evaluateGuard.call(origin, admit, target, origin)) && (!(release = guards.release) || isEmpty(release) || evaluateGuard.call(target, release, origin, target))) && (expr.target ? subject.query(expr.target, target) : subject === target) && (!expr.origin || subject.query(expr.origin, origin))) {
              return expr;
            }
          }
          if (ceiling == null) {
            break;
          }
          subject = subject.superstate;
        }
      };
      return function(target, origin) {
        return (search(target, origin, target)) || (origin !== target ? search(target, origin, origin) : void 0) || (search(target, origin, target.superstate, this.root)) || (search(target, origin, this.root)) || (!target.isIn(origin) ? search(target, origin, origin.superstate, origin.common(target)) : void 0) || null;
      };
    })();

    Region.prototype.determineTransitionTarget = (function() {
      return function(trex, origin) {
        var _ref2;
        if (origin == null) {
          origin = ((_ref2 = this._transition) != null ? _ref2.origin : void 0) || this._current;
        }
        if (typeof trex === 'string') {
          return trex = origin.transition(trex, VIA_SUPER | VIA_PROTO);
        }
      };
    })();

    Region.prototype.go = function(target, options, callback) {
      var origin, transitionExpression, _ref2;
      origin = ((_ref2 = this._transition) != null ? _ref2.origin : void 0) || this._current;
      transitionExpression = this.getTransitionExpression(target, origin);
      if (this.attributes & STRICT) {
        if (transitionExpression == null) {
          throw new Error("Undefined transition '" + origin + "' -> '" + target + "'");
        }
      } else {
        transitionExpression = defaultTransitionExpression;
      }
      return this.schedule(transitionExpression, target, options, callback);
    };

    Region.prototype["do"] = function(transitionExpression, options, callback) {
      var origin, target, _ref2;
      origin = ((_ref2 = this._transition) != null ? _ref2.origin : void 0) || this._current;
      target = this.determineTransitionTarget(transitionExpression, origin);
      if (target == null) {
        throw new Error("Ambiguous target '" + origin + "' ':" + transitionExpression.name + "'");
      }
      return this.schedule(transitionExpression, target, options, callback);
    };

    Region.prototype.schedule = function(transitionExpression, target, options, callback) {
      if (~this.attributes & IMMEDIATE && this._state & TRANSITIONING) {
        this._queue.push(arguments);
        return;
      }
      return this.execute.apply(this, arguments);
    };

    Region.prototype.execute = function(transitionExpression, target, options, callback) {
      var admitted, args, ascend, ascendant, current, descend, domain, name, origin, owner, previous, released, retainee, root, selector, source, subregion, symbol, targetOwner, transition, _ref2;
      if (typeof options === 'function' && (callback == null)) {
        callback = options;
        options = void 0;
      }
      if (!(this._state & ACTIVE)) {
        return fail({
          message: "Concurrency: inactive region '" + this + "'"
        }, callback);
      }
      root = this.root, owner = this.owner;
      current = this._current;
      previous = this._transition;
      origin = (previous != null ? previous.origin : void 0) || current;
      source = previous || origin;
      if (origin.attributes & FINAL) {
        return fail({
          message: "Origin: state '" + origin + "' is final"
        }, callback);
      }
      selector = target instanceof State ? target.path() : target;
      target = origin.query(selector);
      targetOwner = target != null ? target.owner : void 0;
      if (!(owner === targetOwner || isPrototypeOf.call(targetOwner, owner))) {
        return fail({
          message: "Target: invalid state '" + selector + "'"
        }, callback);
      }
      if (options != null) {
        args = (isArray(options)) || (type(options)) === 'arguments' ? options : options.args;
        if (args != null) {
          args = slice.call(args);
        }
      }
      if (target.attributes & RETAINED) {
        if (retainee = target.query(target._.retaineePath)) {
          target = retainee;
        }
      }
      while (target.attributes & ABSTRACT) {
        if (!(target = target.defaultSubstate())) {
          return fail({
            message: "Abstraction: no concrete target"
          }, callback);
        }
      }
      if (!(options != null ? options.forced : void 0)) {
        released = evaluateGuard(origin, 'release', target);
        admitted = evaluateGuard(target, 'admit', origin);
        if (!(released && admitted)) {
          symbol = !released && !admitted ? "|->|" : !released ? "| ->" : !admitted ? "-> |" : void 0;
          return fail({
            message: "Guarded: '" + origin + "' " + symbol + " '" + target + "'"
          }, callback);
        }
      }
      if (origin.attributes & CONCURRENT) {
        _ref2 = origin._.substates;
        for (name in _ref2) {
          subregion = _ref2[name];
          subregion.concurrencyDeactivated();
        }
      }
      if ((target != null ? target.root : void 0) !== root) {
        target = target.virtualize(this);
        if (target.attributes & CONCURRENT) {
          target.realize();
        }
      }
      domain = source.common(target);
      ascendant = source;
      while (ascendant !== domain) {
        if (ascendant.attributes & CONCLUSIVE) {
          return fail({
            message: "Conclusive: cannot exit state '" + ascendant + "'"
          }, callback);
        }
        ascendant = ascendant.superstate;
      }
      transition = new Transition(target, source, transitionExpression);
      if (previous != null) {
        previous.divertTo(transition);
      }
      ascend = function() {
        var eventArgs, _ref3, _results;
        _ref3 = transition = this._transition, origin = _ref3.origin, source = _ref3.source, domain = _ref3.domain;
        eventArgs = [transition, args];
        source.emit('depart', eventArgs, VIA_PROTO);
        this._current = this._transition = transition;
        transition.emit('enter', VIA_NONE);
        ascendant = source;
        _results = [];
        while (ascendant !== domain) {
          if (ascendant.attributes & RETAINED) {
            ascendant._.retaineePath = origin.path();
          }
          ascendant.emit('exit', eventArgs, VIA_PROTO);
          _results.push(transition.superstate = ascendant = ascendant.superstate);
        }
        return _results;
      };
      return descend = function() {
        var descendant, pathToState, _ref3;
        _ref3 = transition = this._transition, origin = _ref3.origin, domain = _ref3.domain, target = _ref3.target;
        if ((transition == null) || transition.aborted) {
          return fail({
            message: ""
          }, callback);
        }
        descendant = target;
        pathToState = [];
        while (descendant !== domain) {
          pathToState.push(descendant);
          descendant = descendant.superstate;
        }
        while (descendant = pathToState.pop()) {
          transition.superstate = descendant;
          descendant.emit('enter', eventArgs, VIA_PROTO);
          if (descendant.attributes & CONCLUSIVE) {
            this.emit('conclude', descendant, VIA_PROTO);
          }
          if (transition.aborted) {
            return fail({
              message: ""
            }, callback);
          }
        }
        transition.emit('exit', VIA_NONE);
        if (transition.aborted) {
          return fail({
            message: ""
          }, callback);
        }
        return this._current = target;
      };
    };

    Region.prototype.change = function(target, options) {
      var admitted, args, current, domain, eventArgs, name, origin, owner, released, retainee, root, s, source, subregion, targetOwner, transition, _ref2, _ref3;
      if (!(this._state & ACTIVE)) {
        return null;
      }
      root = this.root, owner = this.owner;
      current = this._current;
      transition = this._transition;
      origin = (transition != null ? transition.origin : void 0) || current;
      if (origin.attributes & FINAL) {
        return null;
      }
      if (!(target instanceof State)) {
        target = target === '' ? root : origin.query(target);
      }
      if (target == null) {
        return null;
      }
      targetOwner = target.owner;
      if (owner !== targetOwner && !targetOwner.isPrototypeOf(owner)) {
        return null;
      }
      if (options != null) {
        args = (isArray(options)) || (type(options)) === 'arguments' ? options : options.args;
        if (args != null) {
          args = slice.call(args);
        }
      }
      if (target.attributes & RETAINED) {
        if (retainee = target.query(target._.retaineePath)) {
          target = retainee;
        }
      }
      while (target.attributes & ABSTRACT) {
        if (!(target = target.defaultSubstate())) {
          return null;
        }
      }
      if (!(options != null ? options.forced : void 0)) {
        released = evaluateGuard(origin, 'release', target);
        admitted = evaluateGuard(target, 'admit', origin);
        if (!(released && admitted)) {
          if (options != null) {
            if ((_ref2 = options.failure) != null) {
              if (typeof _ref2.call === "function") {
                _ref2.call(this);
              }
            }
          }
          return null;
        }
      }
      if (origin.attributes & CONCURRENT) {
        _ref3 = origin._.substates;
        for (name in _ref3) {
          subregion = _ref3[name];
          subregion.concurrencyDeactivated();
        }
      }
      if ((target != null ? target.root : void 0) !== root) {
        target = target.virtualize(this);
        if (target.attributes & CONCURRENT) {
          target.realize();
        }
      }
      source = current;
      domain = source.common(target);
      s = source;
      while (s !== domain) {
        if (s.attributes & CONCLUSIVE) {
          return null;
        }
        s = s.superstate;
      }
      if (transition != null) {
        transition.abort();
      }
      this._transition = transition = new Transition(target, source, (this.getTransitionExpression(target, origin)) || defaultTransitionExpression);
      eventArgs = [transition, args];
      source.emit('depart', eventArgs, VIA_PROTO);
      if (transition.aborted) {
        this._transition = transition = null;
      }
      if (transition) {
        this._current = transition;
        transition.emit('enter', VIA_NONE);
        if (transition.aborted) {
          this._transition = transition = null;
        }
      }
      s = source;
      while (transition && s !== domain) {
        if (s.attributes & RETAINED) {
          s._.retaineePath = origin.path();
        }
        s.emit('exit', eventArgs, VIA_PROTO);
        transition.superstate = s = s.superstate;
        if (transition.aborted) {
          this._transition = transition = null;
        }
      }
      if (transition != null) {
        transition.callback = function() {
          var pathToState, ss, substate, _ref4;
          while (true) {
            if (!((transition != null) && !transition.aborted)) {
              break;
            }
            s = target;
            pathToState = [];
            while (s !== domain) {
              pathToState.push(s);
              s = s.superstate;
            }
            while (substate = pathToState.pop()) {
              transition.superstate = substate;
              substate.emit('enter', eventArgs, VIA_PROTO);
              if (substate.attributes & CONCLUSIVE) {
                this.emit('conclude', substate, VIA_PROTO);
              }
              if (transition.aborted) {
                break;
              }
            }
            transition.emit('exit', VIA_NONE);
            if (transition.aborted) {
              break;
            }
            this._current = target;
            if (target.attributes & FINAL) {
              this._state = this.attributes & SINGULAR ? FINALIZED | TERMINATED : FINALIZED;
            }
            target.emit('arrive', eventArgs, VIA_PROTO);
            s = origin;
            while (s.attributes & VIRTUAL) {
              ss = s.superstate;
              s.destroy();
              s = ss;
            }
            if (target.attributes & CONCURRENT) {
              this.fork(target, transition);
            }
            transition.destroy();
            this._transition = null;
            if (options != null) {
              if ((_ref4 = options.success) != null) {
                if (typeof _ref4.call === "function") {
                  _ref4.call(this);
                }
              }
            }
            return target;
          }
          return this._transition = null;
        };
      }
      return (transition != null ? transition.start.apply(transition, args) : void 0) || this._current;
    };

    return Region;

  })(State);

  StateExpression = require('./state-expression');

  Transition = require('./transition');

  TransitionExpression = require('./transition-expression');

  defaultTransitionExpression = new TransitionExpression;

}).call(this);
