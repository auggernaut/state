// Generated by CoffeeScript 1.6.3
(function() {
  var GuardMap, O,
    __hasProp = {}.hasOwnProperty;

  O = require('omicron');

  module.exports = GuardMap = (function() {
    var coerceToPredicates, falsePredicate, interpret, isArray, isEmpty, predicateOf, trim, truePredicate;

    trim = O.trim, isArray = O.isArray, isEmpty = O.isEmpty;

    function GuardMap(guardType, expression) {
      this.guardType = guardType;
      this.map = interpret(expression);
    }

    truePredicate = function() {
      return true;
    };

    falsePredicate = function() {
      return false;
    };

    predicateOf = function(value) {
      if (value) {
        return truePredicate;
      } else {
        return falsePredicate;
      }
    };

    coerceToPredicates = function(list) {
      var element, index, _i, _len;
      for (index = _i = 0, _len = list.length; _i < _len; index = ++_i) {
        element = list[index];
        if (typeof element !== 'function') {
          list[index] = predicateOf(element);
        }
      }
      return list;
    };

    interpret = function(expression) {
      var list, map, selector;
      if (expression == null) {
        return null;
      }
      if (typeof expression === 'string') {
        map = {};
        map[expression] = [truePredicate];
        return map;
      } else if (typeof expression === 'function') {
        return {
          '***': [expression]
        };
      } else if (isArray(expression)) {
        return {
          '***': coerceToPredicates(expression.slice(0))
        };
      } else if (typeof expression === 'object') {
        map = {};
        for (selector in expression) {
          if (!__hasProp.call(expression, selector)) continue;
          list = expression[selector];
          list = isArray(list) ? list.slice(0) : [list];
          map[selector] = coerceToPredicates(list);
        }
        return map;
      } else {
        return {
          '***': [predicateOf(expression)]
        };
      }
    };

    GuardMap.prototype.get = function(selector) {
      var _ref;
      return (_ref = this.map[selector]) != null ? _ref.slice(0) : void 0;
    };

    GuardMap.prototype.add = function(selector, predicates) {
      var list, map, predicate, _i, _len;
      map = this.map != null ? this.map : this.map = {};
      list = map[selector] != null ? map[selector] : map[selector] = [];
      if (typeof predicates === 'function') {
        list.push(predicates);
      } else if (isArray(predicates)) {
        for (_i = 0, _len = predicates.length; _i < _len; _i++) {
          predicate = predicates[_i];
          if (typeof predicate !== 'function') {
            predicate = predicateOf(predicate);
          }
          list.push(predicate);
        }
      } else {
        list.push(predicateOf(predicates));
      }
    };

    GuardMap.prototype.remove = function(selector) {
      var list;
      if (!(list = this.map[selector])) {
        return null;
      }
      delete this.map[selector];
      return list;
    };

    GuardMap.prototype.evaluate = function(againstState, asState) {
      var context, guardType, matched, owner, predicate, predicates, queryAgainst, selector, selectors, succeededAtLeastOnce, _i, _j, _len, _len1, _ref, _ref1;
      guardType = this.guardType;
      owner = asState.owner;
      if (isEmpty(this.map)) {
        return true;
      }
      queryAgainst = againstState;
      while (!(queryAgainst.root === asState.root || queryAgainst.root.isProtostateOf(asState.root))) {
        if (!(queryAgainst = queryAgainst.protostate)) {
          throw new Error("Unrelated: '" + againstState + "', '" + asState + "'");
        }
      }
      _ref = this.map;
      for (selectors in _ref) {
        if (!__hasProp.call(_ref, selectors)) continue;
        predicates = _ref[selectors];
        if (!((predicates != null ? predicates.length : void 0) > 0)) {
          continue;
        }
        if (!succeededAtLeastOnce) {
          succeededAtLeastOnce = false;
        }
        matched = false;
        _ref1 = trim(selectors).split(/\s*,+\s*/);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          selector = _ref1[_i];
          if (matched = asState.query(selector, queryAgainst)) {
            break;
          }
        }
        if (!matched) {
          continue;
        }
        for (_j = 0, _len1 = predicates.length; _j < _len1; _j++) {
          predicate = predicates[_j];
          if (!(predicate != null)) {
            continue;
          }
          if (predicate === false) {
            return false;
          } else if (typeof predicate === 'function') {
            context = owner;
          } else if (predicate.type === 'state-bound-function') {
            context = asState;
            predicate = predicate.fn;
          } else if (predicate) {
            continue;
          }
          if (!predicate.call(context, againstState, asState, guardType)) {
            return false;
          }
        }
        succeededAtLeastOnce = true;
      }
      return succeededAtLeastOnce || false;
    };

    GuardMap.prototype.clone = function() {
      return new this.constructor(this.guardType, this.map);
    };

    return GuardMap;

  })();

}).call(this);
